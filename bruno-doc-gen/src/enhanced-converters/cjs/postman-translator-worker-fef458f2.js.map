{"version":3,"file":"postman-translator-worker-fef458f2.js","sources":["../../src/workers/postman-translator-worker.js"],"sourcesContent":["const { Worker } = require('node:worker_threads');\nconst path = require('node:path');\nconst os = require('node:os');\n\nfunction getMaxWorkers() {\n  return Math.max(os.availableParallelism(), 1)\n}\n\nclass WorkerPool {\n  constructor(scriptPath, size) {\n    this.workers = [];\n    this.idle = [];\n    this.queue = [];\n    this.scriptPath = scriptPath;\n    this.size = size;\n  }\n\n  // Initialize the worker pool\n  initialize() {\n    for (let i = 0; i < this.size; i++) {\n      const worker = new Worker(this.scriptPath);\n      this.workers.push(worker);\n      this.idle.push(i);\n    }\n  }\n\n  // Run a task on a worker\n  runTask(data) {\n    return new Promise((resolve, reject) => {\n      const task = { data, resolve, reject };\n      \n      if (this.idle.length > 0) {\n        this._runTaskOnWorker(this.idle.shift(), task);\n      } else {\n        this.queue.push(task);\n      }\n    });\n  }\n\n  // Run a task on a specific worker\n  _runTaskOnWorker(workerId, task) {\n    const worker = this.workers[workerId];\n    \n    const messageHandler = (result) => {\n      // Cleanup listeners\n      worker.removeListener('message', messageHandler);\n      worker.removeListener('error', errorHandler);\n      \n      // Mark worker as idle\n      this.idle.push(workerId);\n      \n      // Process queue if tasks are waiting\n      if (this.queue.length > 0) {\n        this._runTaskOnWorker(workerId, this.queue.shift());\n      }\n      \n      // Resolve the task\n      task.resolve(result);\n    };\n    \n    const errorHandler = (err) => {\n      worker.removeListener('message', messageHandler);\n      worker.removeListener('error', errorHandler);\n      \n      this.idle.push(workerId);\n      \n      if (this.queue.length > 0) {\n        this._runTaskOnWorker(workerId, this.queue.shift());\n      }\n      \n      task.reject(err);\n    };\n    \n    worker.on('message', messageHandler);\n    worker.on('error', errorHandler);\n    worker.postMessage(task.data);\n  }\n  \n  // Terminate all workers\n  terminate() {\n    for (const worker of this.workers) {\n      worker.terminate();\n    }\n    this.workers = [];\n    this.idle = [];\n  }\n}\n\n// Helper function to count lines in a script\nfunction countScriptLines(script) {\n  if (!script) return 0;\n  return Array.isArray(script) ? script.length : script.split('\\n').length;\n}\n\n// Calculate complexity of a script entry\nfunction calculateScriptComplexity([uid, entry]) {\n  let totalLines = 0;\n  const { events }  = entry\n  \n  if (events && Array.isArray(events)) {\n    events.forEach(({ script }) => {\n      if (script && script.exec) {\n        totalLines += countScriptLines(script.exec);\n      }\n    });\n  }\n  \n  return { uid, entry, complexity: totalLines || 1 }; // Minimum complexity of 1\n}\n\n// Create balanced batches based on script complexity\nfunction createBalancedBatches(scriptEntries, workerCount) {\n  // Calculate complexity for each script\n  const scriptsWithComplexity = scriptEntries.map(calculateScriptComplexity);\n  \n  // Sort scripts by complexity (descending)\n  scriptsWithComplexity.sort((a, b) => b.complexity - a.complexity);\n  \n  // Initialize batches\n  const batches = Array.from({ length: workerCount }, () => ({ \n    entries: [], \n    totalComplexity: 0 \n  }));\n  \n  // Algorithm: Greedy load balancing\n  // 1. Process scripts in descending order of complexity\n  // 2. Always assign each script to the batch with lowest current load\n  // 3. This minimizes the maximum workload across all workers\n  for (const { uid, entry, complexity } of scriptsWithComplexity) {\n\n    const batchWithLowestComplexity = batches.reduce(\n      (target, current) => current.totalComplexity < target.totalComplexity ? current : target\n    );\n    \n    // Add the script to this batch\n    batchWithLowestComplexity.entries.push({uid, entry});\n    batchWithLowestComplexity.totalComplexity += complexity;\n  }\n  \n  return batches.map(batch => \n    batch.entries.map(({ uid, entry }) => [uid, entry])\n  ).filter(batch => batch.length > 0);\n}\n\nconst scriptTranslationWorker = async (scriptMap) => {\n  // Convert the Map to an array of entries\n  const scriptEntries = Array.from(scriptMap.entries());\n  const maxWorkers = getMaxWorkers();\n  \n  // For very small collections, don't parallelize\n  if (scriptEntries.length <= 50) {\n    const workerPool = new WorkerPool(path.join(__dirname,'./src/workers/scripts/translate-postman-scripts.js'), 1);\n    workerPool.initialize();\n    \n    try {\n      const translatedScripts = new Map();\n      const result = await workerPool.runTask({ scripts: scriptEntries });\n      \n      if (result.error) {\n        console.error('Error in script translation worker:', result.error);\n        throw new Error(result.error);\n      }\n      \n      result.forEach(([uid, { request }]) => {\n        translatedScripts.set(uid, { request });\n      });\n      \n      return translatedScripts;\n    } finally {\n      workerPool.terminate();\n    }\n  }\n  \n\n  const workerCount = Math.min(maxWorkers, 4);\n  \n  // Create balanced batches based on script complexity\n  const batches = createBalancedBatches(scriptEntries, workerCount);\n  \n  const translatedScripts = new Map();  \n\n  // Create worker pool with optimal size\n  const workerPool = new WorkerPool(path.join(__dirname,'./src/workers/scripts/translate-postman-scripts.js'), workerCount);\n  workerPool.initialize();\n\n  // Process all batches in parallel using worker pool\n  const batchPromises = batches.map(batch => {\n    return workerPool.runTask({ scripts: batch })\n      .then(modScripts => {\n        modScripts.forEach(([name, { request }]) => {\n          translatedScripts.set(name, { request });\n        });\n      })\n      .catch(err => {\n        console.error('Error in script translation worker:', err);\n        throw new Error(err);\n      });\n  });\n\n  // Wait for all batches to complete\n  try {\n    await Promise.allSettled(batchPromises);\n  } finally {\n    // Clean up worker pool\n    workerPool.terminate();\n  }\n\n  return translatedScripts;\n};\n\nexport default scriptTranslationWorker"],"names":["Worker","require","path","os","WorkerPool","constructor","scriptPath","size","this","workers","idle","queue","initialize","i","worker","push","runTask","data","Promise","resolve","reject","task","length","_runTaskOnWorker","shift","workerId","messageHandler","result","removeListener","errorHandler","err","on","postMessage","terminate","calculateScriptComplexity","uid","entry","totalLines","events","Array","isArray","forEach","script","exec","split","countScriptLines","complexity","async","scriptMap","scriptEntries","from","entries","maxWorkers","Math","max","availableParallelism","workerPool","join","__dirname","translatedScripts","Map","scripts","error","console","Error","request","set","workerCount","min","batches","scriptsWithComplexity","map","sort","a","b","totalComplexity","batchWithLowestComplexity","reduce","target","current","batch","filter","createBalancedBatches","batchPromises","then","modScripts","name","catch","allSettled"],"mappings":"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"}